\section{Algorithms}
\label{sec:algorithms}

This section details practical procedures and complexity profiles for DST.

\subsection{Vocabulary Induction with Grammar Filters}

We build counts for substrings up to length $N$ and apply grammar constraints before admitting tokens into $\mathcal{V}$. Compared to BPE merges, this strategy directly proposes candidate strings that preserve domain boundaries.

\begin{algorithm}[H]
\caption{Counted n‑gram proposal with grammar gating}
\label{alg:ngram}
\begin{algorithmic}[1]
\REQUIRE Corpus $\mathcal{D}$, max n‑gram $N$, threshold $\theta$, grammar $\mathcal{G}$
\STATE Initialize counts $f(\cdot) \leftarrow 0$; $\mathcal{V} \leftarrow \Sigma$
\FOR{sequence $s \in \mathcal{D}$} \FOR{$n=1$ to $N$} \FOR{substring $u$ of $s$ of length $n$}
  \STATE $f(u) \leftarrow f(u)+1$
\ENDFOR \ENDFOR \ENDFOR
\FOR{string $u$ with $f(u) > \theta$}
  \IF{$u$ matches grammar $\mathcal{G}$}
    \STATE add $u$ to $\mathcal{V}$
  \ENDIF
\ENDFOR
\STATE Add byte fallback tokens \texttt{<Bxx>} for $x\in[0,255]$
\RETURN $\mathcal{V}$
\end{algorithmic}
\end{algorithm}

\textbf{Complexity.} $O(|\mathcal{D}|N)$ time with streaming or shard‑parallel counting; memory proportional to the number of retained candidates.

\subsection{DFST Compilation}

We compile a trie and emit compact transition tables for runtime encoding/decoding. No $\epsilon$ transitions are permitted; terminal nodes store token IDs.

\begin{algorithm}[H]
\caption{Trie compilation to DFST}
\label{alg:compile}
\begin{algorithmic}[1]
\REQUIRE Vocabulary $\mathcal{V}$
\STATE Build trie nodes for all prefixes of $\mathcal{V}$
\FOR{state $q$ and input symbol $a\in\Sigma$}
  \STATE define transition $\delta(q,a)$ to the next prefix state (or reject)
  \IF{the reached state is a token end}
    \STATE emit token ID and reset to root for maximal‑munch
  \ENDIF
\ENDFOR
\RETURN Encoder/decoder tables
\end{algorithmic}
\end{algorithm}

\textbf{Complexity.} $O(|\mathcal{V}|)$ build, $O(|x|)$ encode/decode.

\subsection{Optional K‑Best Marginalization}

For overlapping admissible paths (rare under strict grammar), we approximate $P(x)$ via top‑$K$ beam search over the DFST (Algorithm~\ref{alg:kbest}). This preserves consistency on dominant paths and yields calibrated likelihoods.

\subsection{Engineering Notes}

- \textbf{Streaming counts.} Use count‑min sketch or shard merges for large corpora.
- \textbf{Cold‑start.} Begin with delimiter/identifier classes, then admit frequent k‑mers.
- \textbf{Compatibility.} Export artifacts to \texttt{tokenizers} schema for drop‑in replacement.
- \textbf{Safety.} Enforce non‑erasing and multiplicativity at compile time; reject candidates that violate constraints.
